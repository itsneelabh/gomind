// Code generated by metadata extraction; DO NOT EDIT.

package capabilities

import (
	"encoding/json"
	"log"
	"reflect"
)

// embeddedAgentMetadata contains capability metadata extracted from agent source files
var embeddedAgentMetadata = `{
  "main": [
    {
      "name": "get-market-data",
      "method": "GetMarketData",
      "description": "Retrieves real-time and historical market data for specified symbols",
      "business_value": "Provides accurate, up-to-date market information for investment decisions",
      "tags": ["market-data", "financial", "real-time"],
      "input_schema": {
        "type": "object",
        "properties": {
          "symbol": {"type": "string", "description": "Stock symbol (e.g., AAPL, GOOGL)"}
        },
        "required": ["symbol"]
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "price": {"type": "number"},
          "change": {"type": "number"},
          "volume": {"type": "number"}
        }
      }
    },
    {
      "name": "analyze-technicals",
      "method": "AnalyzeTechnicals",
      "description": "Performs technical analysis on market data using various indicators",
      "business_value": "Provides quantitative analysis to support trading and investment strategies",
      "tags": ["technical-analysis", "indicators", "trading"],
      "input_schema": {
        "type": "object",
        "properties": {
          "symbol": {"type": "string"},
          "timeframe": {"type": "string", "enum": ["1h", "4h", "1d", "1w"]}
        },
        "required": ["symbol"]
      }
    },
    {
      "name": "analyze-market-sentiment",
      "method": "AnalyzeMarketSentiment",
      "description": "Analyzes market sentiment using news, social media, and other data sources",
      "business_value": "Provides qualitative insights to complement quantitative analysis",
      "tags": ["sentiment", "news", "social-media"],
      "input_schema": {
        "type": "object",
        "properties": {
          "symbol": {"type": "string"},
          "sources": {"type": "array", "items": {"type": "string"}}
        },
        "required": ["symbol"]
      }
    },
    {
      "name": "generate-investment-recommendation",
      "method": "GenerateInvestmentRecommendation",
      "description": "Generates comprehensive investment recommendations based on multiple analysis factors",
      "business_value": "Provides actionable investment advice combining technical and fundamental analysis",
      "tags": ["recommendation", "investment", "decision-support"],
      "input_schema": {
        "type": "object",
        "properties": {
          "symbol": {"type": "string"},
          "risk_tolerance": {"type": "string", "enum": ["low", "medium", "high"]},
          "time_horizon": {"type": "string", "enum": ["short", "medium", "long"]}
        },
        "required": ["symbol"]
      }
    },
    {
      "name": "assess-risk-profile",
      "method": "AssessRiskProfile",
      "description": "Evaluates investment risk based on market conditions and asset characteristics",
      "business_value": "Helps investors understand and manage portfolio risk",
      "tags": ["risk-assessment", "portfolio-management"],
      "input_schema": {
        "type": "object",
        "properties": {
          "symbol": {"type": "string"},
          "portfolio_context": {"type": "object"}
        },
        "required": ["symbol"]
      }
    },
    {
      "name": "analyze-investment",
      "method": "AnalyzeInvestment",
      "description": "Comprehensive investment analysis orchestrating multiple analysis services",
      "business_value": "Provides end-to-end investment analysis workflow for complete decision support",
      "tags": ["orchestration", "comprehensive-analysis", "workflow"],
      "input_schema": {
        "type": "object",
        "properties": {
          "symbol": {"type": "string"},
          "analysis_type": {"type": "string", "enum": ["quick", "detailed", "comprehensive"]}
        },
        "required": ["symbol"]
      }
    },
    {
      "name": "health-check-system",
      "method": "HealthCheck",
      "description": "Performs system health checks across all connected services",
      "business_value": "Ensures system reliability and availability for critical financial operations",
      "tags": ["health-check", "monitoring", "system-status"],
      "input_schema": {
        "type": "object",
        "properties": {
          "include_dependencies": {"type": "boolean"}
        }
      }
    }
  ]
}`

// LoadEmbeddedMetadata loads capability metadata that was embedded at build time
func LoadEmbeddedMetadata() map[string][]CapabilityMetadata {
	var metadata map[string][]CapabilityMetadata

	if err := json.Unmarshal([]byte(embeddedAgentMetadata), &metadata); err != nil {
		log.Printf("Warning: Could not unmarshal embedded metadata: %v", err)
		return make(map[string][]CapabilityMetadata)
	}

	return metadata
}

// GetEmbeddedCapabilities returns capabilities for a specific agent type
func GetEmbeddedCapabilities(agentType reflect.Type) []CapabilityMetadata {
	metadata := LoadEmbeddedMetadata()

	// Debug logging to understand what we're looking for
	log.Printf("[DEBUG] GetEmbeddedCapabilities called with agentType: %s", agentType.Name())
	log.Printf("[DEBUG] AgentType PkgPath: %s", agentType.PkgPath())
	log.Printf("[DEBUG] Available metadata keys: %v", getMapKeys(metadata))

	// Try different package name variants
	packageVariants := []string{
		"main", // Most agents are in main package
		agentType.PkgPath(),
		agentType.Name(),
	}

	for _, variant := range packageVariants {
		log.Printf("[DEBUG] Trying variant: %s", variant)
		if capabilities, exists := metadata[variant]; exists {
			log.Printf("[DEBUG] Found %d capabilities for variant: %s", len(capabilities), variant)
			return capabilities
		}
	}

	log.Printf("[DEBUG] No capabilities found for any variant")
	return []CapabilityMetadata{}
}

// Helper function to get map keys for debugging
func getMapKeys(m map[string][]CapabilityMetadata) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}
